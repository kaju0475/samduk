[
  {
    "projectId": "201b0074-e795-45a3-a624-3bd3b786efd1",
    "testId": "52a1bc05-da95-4e60-b0ad-e3f9b9efaafa",
    "userId": "a45884c8-30e1-70e2-d3ed-ca08522119ab",
    "title": "TC001-user login functionality",
    "description": "Verify that the user can successfully log in using the /api/auth/login endpoint with valid credentials and that session management is correctly handled.",
    "code": "import os\nos.environ['DB_FILENAME'] = 'db.test.json'\n\nimport requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\n\ndef test_user_login_functionality():\n    login_url = f\"{BASE_URL}/api/auth/login\"\n\n    # Valid credentials for test - assuming these are valid for test DB\n    # Replace with actual valid test credentials if known\n    payload = {\n        \"username\": \"testuser\",\n        \"password\": \"testpassword\"\n    }\n\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    try:\n        # Perform login request\n        response = requests.post(login_url, json=payload, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Login request failed: {e}\"\n\n    # Assert HTTP 200 OK\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    # Parse JSON response\n    try:\n        data = response.json()\n    except Exception as e:\n        assert False, f\"Response is not valid JSON: {e}\"\n\n    # Validate presence of token/session info (common in login)\n    assert 'token' in data or 'sessionId' in data or 'accessToken' in data, (\n        \"Login response does not contain a session token or access token\")\n\n    # Optionally check that token is non-empty string\n    token = data.get('token') or data.get('sessionId') or data.get('accessToken')\n    assert isinstance(token, str) and len(token) > 0, \"Token/session id is empty or invalid\"\n\n    # Further test session management by attempting a logout or other authorized call could be done,\n    # but not requested explicitly in this test case\n\n\ntest_user_login_functionality()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 27, in test_user_login_functionality\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: http://localhost:3000/api/auth/login\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 52, in <module>\n  File \"<string>\", line 29, in test_user_login_functionality\nAssertionError: Login request failed: 401 Client Error: Unauthorized for url: http://localhost:3000/api/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T06:37:10.700Z",
    "modified": "2026-01-13T06:37:43.866Z"
  },
  {
    "projectId": "201b0074-e795-45a3-a624-3bd3b786efd1",
    "testId": "f30ac206-be3b-477d-8d33-d9e7bc0d3b0f",
    "userId": "a45884c8-30e1-70e2-d3ed-ca08522119ab",
    "title": "TC002-user logout functionality",
    "description": "Verify that the user can successfully log out using the /api/auth/logout endpoint and that the session is properly terminated.",
    "code": "import os\nos.environ[\"DB_FILENAME\"] = \"db.test.json\"\n\nimport requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_user_logout_functionality():\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    logout_url = f\"{BASE_URL}/api/auth/logout\"\n\n    # Sample valid credentials (adjust if needed)\n    credentials = {\n        \"username\": \"testuser\",\n        \"password\": \"testpass\"\n    }\n\n    session = requests.Session()\n\n    # Attempt login to create a session or token for logout\n    try:\n        login_resp = session.post(login_url, json=credentials, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed with status code {login_resp.status_code}\"\n        # Usually logout requires auth token or cookies, using session should handle cookies if any\n\n        # Logout request\n        logout_resp = session.post(logout_url, timeout=TIMEOUT)\n        assert logout_resp.status_code == 200, f\"Logout failed with status code {logout_resp.status_code}\"\n\n        # Validate session terminated: attempt accessing a protected resource or logout again should fail\n        # Here we try another logout which should fail or unauthorized\n        logout_resp_2 = session.post(logout_url, timeout=TIMEOUT)\n        assert logout_resp_2.status_code in (401, 403), \"Session was not properly terminated after logout\"\n    finally:\n        session.close()\n\ntest_user_logout_functionality()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 38, in <module>\n  File \"<string>\", line 24, in test_user_logout_functionality\nAssertionError: Login failed with status code 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T06:37:10.708Z",
    "modified": "2026-01-13T06:37:42.814Z"
  },
  {
    "projectId": "201b0074-e795-45a3-a624-3bd3b786efd1",
    "testId": "e98e7325-34d4-40d1-bec2-715f9a8ddb9a",
    "userId": "a45884c8-30e1-70e2-d3ed-ca08522119ab",
    "title": "TC003-qr login functionality",
    "description": "Verify that the user can authenticate using the QR code login via the /api/auth/qr-login endpoint and that the authentication flow completes successfully.",
    "code": "import os\nos.environ[\"DB_FILENAME\"] = \"db.test.json\"\n\nimport requests\nimport json\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_qr_login_functionality():\n    url = f\"{BASE_URL}/api/auth/qr-login\"\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n    # Fix: add a required payload field 'qrCode' as string\n    payload = {\"qrCode\": \"dummy-qr-code\"}\n\n    try:\n        response = requests.post(url, headers=headers, data=json.dumps(payload), timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except json.JSONDecodeError:\n        assert False, \"Response is not valid JSON\"\n\n    assert \"token\" in data or \"user\" in data, \"Authentication not successful or token/user data missing\"\n\ntest_qr_login_functionality()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 33, in <module>\n  File \"<string>\", line 24, in test_qr_login_functionality\nAssertionError: Expected status code 200 but got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T06:37:10.714Z",
    "modified": "2026-01-13T06:37:55.481Z"
  },
  {
    "projectId": "201b0074-e795-45a3-a624-3bd3b786efd1",
    "testId": "d618731d-dde6-449b-8911-b46068c613a7",
    "userId": "a45884c8-30e1-70e2-d3ed-ca08522119ab",
    "title": "TC004-cylinder creation update and listing",
    "description": "Verify that cylinders can be created, updated, and listed correctly using the /api/master/cylinders endpoint with proper data validation and no data loss.",
    "code": "import os\nos.environ[\"DB_FILENAME\"] = \"db.test.json\"\n\nimport requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nHEADERS = {\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\n\ndef test_tc004_cylinder_creation_update_and_listing():\n    \"\"\"\n    Verify that cylinders can be created, updated, and listed correctly using the /api/master/cylinders endpoint\n    with proper data validation and no data loss.\n    \"\"\"\n    created_cylinder_id = None\n    try:\n        # Step 1: Create a new cylinder\n        create_payload = {\n            \"name\": f\"Test Cylinder {uuid.uuid4()}\",\n            \"description\": \"Test description\"\n        }\n        create_resp = requests.post(\n            f\"{BASE_URL}/api/master/cylinders\",\n            json=create_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert create_resp.status_code == 201 or create_resp.status_code == 200, \\\n            f\"Unexpected status code on create: {create_resp.status_code}\"\n        create_data = create_resp.json()\n        assert \"id\" in create_data and create_data[\"id\"], \"Created cylinder has no ID\"\n        created_cylinder_id = create_data[\"id\"]\n\n        # Verify the returned data matches what was sent (except id)\n        for key in create_payload:\n            assert create_data.get(key) == create_payload[key], \\\n                f\"Mismatch in created cylinder field {key}\"\n\n        # Step 2: Update the created cylinder with new data\n        update_payload = {\n            \"id\": created_cylinder_id,\n            \"name\": create_payload[\"name\"] + \" Updated\",\n            \"description\": \"Updated description\"\n        }\n        update_resp = requests.put(\n            f\"{BASE_URL}/api/master/cylinders\",\n            json=update_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert update_resp.status_code == 200, \\\n            f\"Unexpected status code on update: {update_resp.status_code}\"\n        update_data = update_resp.json()\n        # Validate updated fields match\n        for key in update_payload:\n            if key != \"id\":\n                assert update_data.get(key) == update_payload[key], \\\n                    f\"Mismatch in updated cylinder field {key}\"\n\n        # Step 3: List cylinders and verify the updated cylinder is present and correct\n        list_resp = requests.get(\n            f\"{BASE_URL}/api/master/cylinders\",\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert list_resp.status_code == 200, f\"Unexpected status code on list: {list_resp.status_code}\"\n        cylinders_list = list_resp.json()\n        # We expect list to be a list/array\n        assert isinstance(cylinders_list, list), \"List response is not a list\"\n\n        # Find the updated cylinder in the list\n        found = None\n        for cyl in cylinders_list:\n            if cyl.get(\"id\") == created_cylinder_id:\n                found = cyl\n                break\n        assert found is not None, \"Updated cylinder not found in list\"\n\n        # Validate the data in the list matches the updated data\n        for key in update_payload:\n            if key != \"id\":\n                assert found.get(key) == update_payload[key], \\\n                    f\"Mismatch in listed cylinder field {key}\"\n\n    finally:\n        if created_cylinder_id is not None:\n            # Cleanup: delete the created cylinder\n            # The PRD doesn't define a DELETE method, so we skip if not supported.\n            # If DELETE supported:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/api/master/cylinders/{created_cylinder_id}\",\n                    headers=HEADERS,\n                    timeout=TIMEOUT,\n                )\n            except Exception:\n                pass\n\n\ntest_tc004_cylinder_creation_update_and_listing()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 104, in <module>\n  File \"<string>\", line 32, in test_tc004_cylinder_creation_update_and_listing\nAssertionError: Unexpected status code on create: 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T06:37:10.720Z",
    "modified": "2026-01-13T06:38:19.945Z"
  },
  {
    "projectId": "201b0074-e795-45a3-a624-3bd3b786efd1",
    "testId": "6d119bb3-3694-4f02-ac24-ceadaabefe2e",
    "userId": "a45884c8-30e1-70e2-d3ed-ca08522119ab",
    "title": "TC005-charging process actions",
    "description": "Verify that charging actions (START and COMPLETE) can be processed correctly for specified cylinders using the /api/work/charging endpoint and that cylinder statuses are updated accordingly.",
    "code": "import os\nos.environ[\"DB_FILENAME\"] = \"db.test.json\"\n\nimport requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\n# Assuming a token based auth but no credentials were provided, so no auth header is used here.\n# If auth token was provided, add headers={\"Authorization\": \"Bearer <token>\"}\n\ndef test_charging_process_actions():\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Step 1: Create a new cylinder to use for charging actions\n    cylinder_payload = {\n        \"serialNumber\": \"SN-\" + str(uuid.uuid4()),\n        \"gasType\": \"Type-A\",\n        \"status\": \"READY\"\n    }\n    try:\n        create_resp = requests.post(\n            f\"{BASE_URL}/api/master/cylinders\",\n            json=cylinder_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert create_resp.status_code == 200 or create_resp.status_code == 201, f\"Create cylinder failed: {create_resp.text}\"\n        created_cylinder = create_resp.json()\n        serial_number = created_cylinder.get(\"serialNumber\")\n        assert serial_number, \"Created cylinder has no serialNumber\"\n\n        # Step 2: START charging action\n        start_payload = {\n            \"action\": \"START\",\n            \"cylinders\": [serial_number]\n        }\n        start_resp = requests.post(\n            f\"{BASE_URL}/api/work/charging\",\n            json=start_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert start_resp.status_code == 200, f\"START charging action failed: {start_resp.text}\"\n\n        # Verify status updated to 'CHARGING' or equivalent\n        get_cyl_resp = requests.get(\n            f\"{BASE_URL}/api/master/cylinders\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert get_cyl_resp.status_code == 200, f\"Failed to list cylinders after START charging: {get_cyl_resp.text}\"\n        cylinders = get_cyl_resp.json()\n        matching = [c for c in cylinders if c.get(\"serialNumber\") == serial_number]\n        assert matching, \"Cylinder not found after START charging\"\n        status_after_start = matching[0].get(\"status\")\n        assert status_after_start in [\"CHARGING\", \"STARTED\"], f\"Unexpected status after START charging: {status_after_start}\"\n\n        # Step 3: COMPLETE charging action\n        complete_payload = {\n            \"action\": \"COMPLETE\",\n            \"cylinders\": [serial_number]\n        }\n        complete_resp = requests.post(\n            f\"{BASE_URL}/api/work/charging\",\n            json=complete_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert complete_resp.status_code == 200, f\"COMPLETE charging action failed: {complete_resp.text}\"\n\n        # Verify status updated to 'CHARGED' or equivalent\n        get_cyl_resp2 = requests.get(\n            f\"{BASE_URL}/api/master/cylinders\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert get_cyl_resp2.status_code == 200, f\"Failed to list cylinders after COMPLETE charging: {get_cyl_resp2.text}\"\n        cylinders2 = get_cyl_resp2.json()\n        matching2 = [c for c in cylinders2 if c.get(\"serialNumber\") == serial_number]\n        assert matching2, \"Cylinder not found after COMPLETE charging\"\n        status_after_complete = matching2[0].get(\"status\")\n        assert status_after_complete in [\"CHARGED\", \"COMPLETE\", \"READY\"], f\"Unexpected status after COMPLETE charging: {status_after_complete}\"\n\n    finally:\n        # Clean up - delete the created cylinder\n        if 'serial_number' in locals():\n            requests.put(\n                f\"{BASE_URL}/api/master/cylinders\",\n                json={\"serialNumber\": serial_number, \"deleted\": True},\n                headers=headers,\n                timeout=TIMEOUT\n            )\n\ntest_charging_process_actions()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 96, in <module>\n  File \"<string>\", line 32, in test_charging_process_actions\nAssertionError: Created cylinder has no serialNumber\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T06:37:10.726Z",
    "modified": "2026-01-13T06:38:18.230Z"
  },
  {
    "projectId": "201b0074-e795-45a3-a624-3bd3b786efd1",
    "testId": "dbe85fad-7278-40ff-85c3-f4e08813a484",
    "userId": "a45884c8-30e1-70e2-d3ed-ca08522119ab",
    "title": "TC006-delivery and collection processing",
    "description": "Verify that delivery and collection actions can be processed correctly for specified cylinders and customers using the /api/work/delivery endpoint and that statuses and associations are updated properly.",
    "code": "import os\nos.environ[\"DB_FILENAME\"] = \"db.test.json\"\n\nimport requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef create_cylinder():\n    url = f\"{BASE_URL}/api/master/cylinders\"\n    cylinder_data = {\n        \"serialNumber\": f\"SN-{uuid.uuid4()}\",\n        \"status\": \"AVAILABLE\",\n        \"type\": \"TYPE_A\",\n        \"location\": \"Warehouse 1\"\n    }\n    resp = requests.post(url, json=cylinder_data, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef delete_cylinder(cylinder_id):\n    url = f\"{BASE_URL}/api/master/cylinders\"\n    update_data = {\n        \"id\": cylinder_id,\n        \"status\": \"REMOVED\"\n    }\n    resp = requests.put(url, json=update_data, timeout=TIMEOUT)\n    resp.raise_for_status()\n\ndef create_customer():\n    return f\"test-customer-{uuid.uuid4()}\"\n\ndef test_delivery_and_collection_processing():\n    cylinder_ids = []\n    customer_id = create_customer()\n    try:\n        for _ in range(2):\n            cylinder = create_cylinder()\n            cylinder_ids.append(cylinder[\"id\"])\n\n        delivery_url = f\"{BASE_URL}/api/work/delivery\"\n        headers = {\n            \"Content-Type\": \"application/json\"\n        }\n\n        delivery_payload = {\n            \"action\": \"DELIVERY\",\n            \"cylinders\": cylinder_ids,\n            \"customerId\": customer_id\n        }\n        delivery_resp = requests.post(delivery_url, json=delivery_payload, headers=headers, timeout=TIMEOUT)\n        assert delivery_resp.status_code == 200\n        delivery_data = delivery_resp.json()\n        assert isinstance(delivery_data, dict)\n        assert \"processed\" in delivery_data and delivery_data[\"processed\"] is True\n        assert set(delivery_data.get(\"cylinders\", [])) == set(cylinder_ids)\n        assert delivery_data.get(\"customerId\") == customer_id\n\n        cylinders_url = f\"{BASE_URL}/api/master/cylinders\"\n        list_resp = requests.get(cylinders_url, timeout=TIMEOUT)\n        list_resp.raise_for_status()\n        cylinders_list = list_resp.json()\n        for c in cylinders_list:\n            if c[\"id\"] in cylinder_ids:\n                assert c.get(\"status\") in [\"DELIVERED\", \"OUT_FOR_DELIVERY\"]\n\n        collection_payload = {\n            \"action\": \"COLLECTION\",\n            \"cylinders\": cylinder_ids,\n            \"customerId\": customer_id\n        }\n        collection_resp = requests.post(delivery_url, json=collection_payload, headers=headers, timeout=TIMEOUT)\n        assert collection_resp.status_code == 200\n        collection_data = collection_resp.json()\n        assert isinstance(collection_data, dict)\n        assert \"processed\" in collection_data and collection_data[\"processed\"] is True\n        assert set(collection_data.get(\"cylinders\", [])) == set(cylinder_ids)\n        assert collection_data.get(\"customerId\") == customer_id\n\n        list_resp_after = requests.get(cylinders_url, timeout=TIMEOUT)\n        list_resp_after.raise_for_status()\n        cylinders_list_after = list_resp_after.json()\n        for c in cylinders_list_after:\n            if c[\"id\"] in cylinder_ids:\n                assert c.get(\"status\") in [\"AVAILABLE\", \"COLLECTED\"]\n\n    finally:\n        for cid in cylinder_ids:\n            try:\n                delete_cylinder(cid)\n            except Exception:\n                pass\n\ntest_delivery_and_collection_processing()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 95, in <module>\n  File \"<string>\", line 39, in test_delivery_and_collection_processing\n  File \"<string>\", line 19, in create_cylinder\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 400 Client Error: Bad Request for url: http://localhost:3000/api/master/cylinders\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T06:37:10.732Z",
    "modified": "2026-01-13T06:38:18.232Z"
  },
  {
    "projectId": "201b0074-e795-45a3-a624-3bd3b786efd1",
    "testId": "a49bd808-9e08-4aa7-a49e-0c8e372774bb",
    "userId": "a45884c8-30e1-70e2-d3ed-ca08522119ab",
    "title": "TC007-cylinder history retrieval",
    "description": "Verify that historical data for specific cylinders can be retrieved accurately using the /api/history/cylinder endpoint reflecting all past activities.",
    "code": "import os\nos.environ[\"DB_FILENAME\"] = \"db.test.json\"\nimport requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\nAUTH_TOKEN = \"\"  # Insert valid token if needed or set up a method to get it.\n\ndef test_cylinder_history_retrieval():\n    headers = {\n        \"Authorization\": f\"Bearer {AUTH_TOKEN}\" if AUTH_TOKEN else \"\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    cylinder_id = None\n    created_cylinder = None\n\n    try:\n        # Step 1: Create a cylinder to have history for\n        create_payload = {\n            \"serial_number\": \"TC007-HIST-001\",\n            \"type\": \"TypeA\"\n        }\n        response = requests.post(\n            f\"{BASE_URL}/api/master/cylinders\",\n            json=create_payload,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert response.status_code in [200, 201], \"Failed to create test cylinder\"\n        created_cylinder = response.json()\n        cylinder_id = created_cylinder.get(\"id\")\n        assert cylinder_id, \"Created cylinder response missing ID\"\n\n        # Step 2: Perform a charging START action to generate history\n        charging_payload = {\n            \"action\": \"START\",\n            \"cylinders\": [cylinder_id]\n        }\n        charging_response = requests.post(\n            f\"{BASE_URL}/api/work/charging\",\n            json=charging_payload,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert charging_response.status_code == 200, \"Failed to start charging action\"\n\n        # Step 3: Perform a delivery action to generate more history\n        delivery_payload = {\n            \"action\": \"DELIVERY\",\n            \"cylinders\": [cylinder_id],\n            \"customerId\": \"test-customer-001\"\n        }\n        delivery_response = requests.post(\n            f\"{BASE_URL}/api/work/delivery\",\n            json=delivery_payload,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert delivery_response.status_code == 200, \"Failed to process delivery action\"\n\n        # Step 4: Retrieve cylinder history\n        params = {\"cylinders\": [cylinder_id]}  # Pass list for query parameter\n        history_response = requests.get(\n            f\"{BASE_URL}/api/history/cylinder\",\n            headers=headers,\n            params=params,\n            timeout=TIMEOUT,\n        )\n        assert history_response.status_code == 200, \"Failed to retrieve cylinder history\"\n\n        history_data = history_response.json()\n        assert isinstance(history_data, list), \"History response should be list\"\n        assert any(\n            entry.get(\"cylinderId\") == cylinder_id for entry in history_data\n        ), \"History does not contain entries for the test cylinder\"\n\n        # Additional sanity checks on history content\n        actions = {entry.get(\"action\") for entry in history_data}\n        assert \"START\" in actions or \"DELIVERY\" in actions, \"Expected history actions not found\"\n\n    finally:\n        # Clean up - delete the created cylinder if possible\n        if cylinder_id:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/api/master/cylinders\",\n                    headers=headers,\n                    json={\"id\": cylinder_id},\n                    timeout=TIMEOUT,\n                )\n            except Exception:\n                pass\n\ntest_cylinder_history_retrieval()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 95, in <module>\n  File \"<string>\", line 30, in test_cylinder_history_retrieval\nAssertionError: Failed to create test cylinder\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T06:37:10.738Z",
    "modified": "2026-01-13T06:38:26.273Z"
  },
  {
    "projectId": "201b0074-e795-45a3-a624-3bd3b786efd1",
    "testId": "183da680-a1a8-4c18-93d2-ed4bd4fd8a0f",
    "userId": "a45884c8-30e1-70e2-d3ed-ca08522119ab",
    "title": "TC008-long term inventory reporting",
    "description": "Verify that the system can generate accurate long-term inventory reports using the /api/system/reports/long-term endpoint and that the data is consistent and comprehensive.",
    "code": "import os\nos.environ['DB_FILENAME'] = 'db.test.json'\n\nimport requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_long_term_inventory_reporting():\n    headers = {}\n    try:\n        response = requests.get(\n            f\"{BASE_URL}/api/system/reports/long-term\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code}\"\n        data = response.json()\n        # Accept either dict or list, ensure non-empty\n        assert isinstance(data, (dict, list)), \"Report response should be a JSON object or array\"\n        if isinstance(data, dict):\n            assert data, \"Report JSON object should not be empty\"\n        else:\n            assert len(data) > 0, \"Report JSON array should not be empty\"\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n\ntest_long_term_inventory_reporting()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 28, in <module>\n  File \"<string>\", line 24, in test_long_term_inventory_reporting\nAssertionError: Report JSON array should not be empty\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T06:37:10.743Z",
    "modified": "2026-01-13T06:37:55.486Z"
  }
]
